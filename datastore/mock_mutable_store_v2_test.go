// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package datastore

import (
	"context"

	mock "github.com/stretchr/testify/mock"
)

// NewMockMutableStoreV2 creates a new instance of MockMutableStoreV2. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMutableStoreV2[K Comparable[K], R UniqueRecord[K, R]](t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMutableStoreV2[K, R] {
	mock := &MockMutableStoreV2[K, R]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMutableStoreV2 is an autogenerated mock type for the MutableStoreV2 type
type MockMutableStoreV2[K Comparable[K], R UniqueRecord[K, R]] struct {
	mock.Mock
}

type MockMutableStoreV2_Expecter[K Comparable[K], R UniqueRecord[K, R]] struct {
	mock *mock.Mock
}

func (_m *MockMutableStoreV2[K, R]) EXPECT() *MockMutableStoreV2_Expecter[K, R] {
	return &MockMutableStoreV2_Expecter[K, R]{mock: &_m.Mock}
}

// Add provides a mock function for the type MockMutableStoreV2
func (_mock *MockMutableStoreV2[K, R]) Add(ctx context.Context, record R) error {
	ret := _mock.Called(ctx, record)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, R) error); ok {
		r0 = returnFunc(ctx, record)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMutableStoreV2_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type MockMutableStoreV2_Add_Call[K Comparable[K], R UniqueRecord[K, R]] struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - ctx context.Context
//   - record R
func (_e *MockMutableStoreV2_Expecter[K, R]) Add(ctx interface{}, record interface{}) *MockMutableStoreV2_Add_Call[K, R] {
	return &MockMutableStoreV2_Add_Call[K, R]{Call: _e.mock.On("Add", ctx, record)}
}

func (_c *MockMutableStoreV2_Add_Call[K, R]) Run(run func(ctx context.Context, record R)) *MockMutableStoreV2_Add_Call[K, R] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 R
		if args[1] != nil {
			arg1 = args[1].(R)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMutableStoreV2_Add_Call[K, R]) Return(err error) *MockMutableStoreV2_Add_Call[K, R] {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMutableStoreV2_Add_Call[K, R]) RunAndReturn(run func(ctx context.Context, record R) error) *MockMutableStoreV2_Add_Call[K, R] {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockMutableStoreV2
func (_mock *MockMutableStoreV2[K, R]) Delete(ctx context.Context, key K) error {
	ret := _mock.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, K) error); ok {
		r0 = returnFunc(ctx, key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMutableStoreV2_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockMutableStoreV2_Delete_Call[K Comparable[K], R UniqueRecord[K, R]] struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - key K
func (_e *MockMutableStoreV2_Expecter[K, R]) Delete(ctx interface{}, key interface{}) *MockMutableStoreV2_Delete_Call[K, R] {
	return &MockMutableStoreV2_Delete_Call[K, R]{Call: _e.mock.On("Delete", ctx, key)}
}

func (_c *MockMutableStoreV2_Delete_Call[K, R]) Run(run func(ctx context.Context, key K)) *MockMutableStoreV2_Delete_Call[K, R] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 K
		if args[1] != nil {
			arg1 = args[1].(K)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMutableStoreV2_Delete_Call[K, R]) Return(err error) *MockMutableStoreV2_Delete_Call[K, R] {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMutableStoreV2_Delete_Call[K, R]) RunAndReturn(run func(ctx context.Context, key K) error) *MockMutableStoreV2_Delete_Call[K, R] {
	_c.Call.Return(run)
	return _c
}

// Fetch provides a mock function for the type MockMutableStoreV2
func (_mock *MockMutableStoreV2[K, R]) Fetch(context1 context.Context) ([]R, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Fetch")
	}

	var r0 []R
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]R, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []R); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]R)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMutableStoreV2_Fetch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Fetch'
type MockMutableStoreV2_Fetch_Call[K Comparable[K], R UniqueRecord[K, R]] struct {
	*mock.Call
}

// Fetch is a helper method to define mock.On call
//   - context1 context.Context
func (_e *MockMutableStoreV2_Expecter[K, R]) Fetch(context1 interface{}) *MockMutableStoreV2_Fetch_Call[K, R] {
	return &MockMutableStoreV2_Fetch_Call[K, R]{Call: _e.mock.On("Fetch", context1)}
}

func (_c *MockMutableStoreV2_Fetch_Call[K, R]) Run(run func(context1 context.Context)) *MockMutableStoreV2_Fetch_Call[K, R] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockMutableStoreV2_Fetch_Call[K, R]) Return(vs []R, err error) *MockMutableStoreV2_Fetch_Call[K, R] {
	_c.Call.Return(vs, err)
	return _c
}

func (_c *MockMutableStoreV2_Fetch_Call[K, R]) RunAndReturn(run func(context1 context.Context) ([]R, error)) *MockMutableStoreV2_Fetch_Call[K, R] {
	_c.Call.Return(run)
	return _c
}

// Filter provides a mock function for the type MockMutableStoreV2
func (_mock *MockMutableStoreV2[K, R]) Filter(context1 context.Context, filterFuncs ...FilterFunc[K, R]) ([]R, error) {
	var tmpRet mock.Arguments
	if len(filterFuncs) > 0 {
		tmpRet = _mock.Called(context1, filterFuncs)
	} else {
		tmpRet = _mock.Called(context1)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Filter")
	}

	var r0 []R
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...FilterFunc[K, R]) ([]R, error)); ok {
		return returnFunc(context1, filterFuncs...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...FilterFunc[K, R]) []R); ok {
		r0 = returnFunc(context1, filterFuncs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]R)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, ...FilterFunc[K, R]) error); ok {
		r1 = returnFunc(context1, filterFuncs...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMutableStoreV2_Filter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Filter'
type MockMutableStoreV2_Filter_Call[K Comparable[K], R UniqueRecord[K, R]] struct {
	*mock.Call
}

// Filter is a helper method to define mock.On call
//   - context1 context.Context
//   - filterFuncs ...FilterFunc[K, R]
func (_e *MockMutableStoreV2_Expecter[K, R]) Filter(context1 interface{}, filterFuncs ...interface{}) *MockMutableStoreV2_Filter_Call[K, R] {
	return &MockMutableStoreV2_Filter_Call[K, R]{Call: _e.mock.On("Filter",
		append([]interface{}{context1}, filterFuncs...)...)}
}

func (_c *MockMutableStoreV2_Filter_Call[K, R]) Run(run func(context1 context.Context, filterFuncs ...FilterFunc[K, R])) *MockMutableStoreV2_Filter_Call[K, R] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []FilterFunc[K, R]
		var variadicArgs []FilterFunc[K, R]
		if len(args) > 1 {
			variadicArgs = args[1].([]FilterFunc[K, R])
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockMutableStoreV2_Filter_Call[K, R]) Return(vs []R, err error) *MockMutableStoreV2_Filter_Call[K, R] {
	_c.Call.Return(vs, err)
	return _c
}

func (_c *MockMutableStoreV2_Filter_Call[K, R]) RunAndReturn(run func(context1 context.Context, filterFuncs ...FilterFunc[K, R]) ([]R, error)) *MockMutableStoreV2_Filter_Call[K, R] {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockMutableStoreV2
func (_mock *MockMutableStoreV2[K, R]) Get(context1 context.Context, v K, getOptions ...GetOption) (R, error) {
	var tmpRet mock.Arguments
	if len(getOptions) > 0 {
		tmpRet = _mock.Called(context1, v, getOptions)
	} else {
		tmpRet = _mock.Called(context1, v)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 R
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, K, ...GetOption) (R, error)); ok {
		return returnFunc(context1, v, getOptions...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, K, ...GetOption) R); ok {
		r0 = returnFunc(context1, v, getOptions...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(R)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, K, ...GetOption) error); ok {
		r1 = returnFunc(context1, v, getOptions...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMutableStoreV2_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockMutableStoreV2_Get_Call[K Comparable[K], R UniqueRecord[K, R]] struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - context1 context.Context
//   - v K
//   - getOptions ...GetOption
func (_e *MockMutableStoreV2_Expecter[K, R]) Get(context1 interface{}, v interface{}, getOptions ...interface{}) *MockMutableStoreV2_Get_Call[K, R] {
	return &MockMutableStoreV2_Get_Call[K, R]{Call: _e.mock.On("Get",
		append([]interface{}{context1, v}, getOptions...)...)}
}

func (_c *MockMutableStoreV2_Get_Call[K, R]) Run(run func(context1 context.Context, v K, getOptions ...GetOption)) *MockMutableStoreV2_Get_Call[K, R] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 K
		if args[1] != nil {
			arg1 = args[1].(K)
		}
		var arg2 []GetOption
		var variadicArgs []GetOption
		if len(args) > 2 {
			variadicArgs = args[2].([]GetOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockMutableStoreV2_Get_Call[K, R]) Return(v1 R, err error) *MockMutableStoreV2_Get_Call[K, R] {
	_c.Call.Return(v1, err)
	return _c
}

func (_c *MockMutableStoreV2_Get_Call[K, R]) RunAndReturn(run func(context1 context.Context, v K, getOptions ...GetOption) (R, error)) *MockMutableStoreV2_Get_Call[K, R] {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockMutableStoreV2
func (_mock *MockMutableStoreV2[K, R]) Update(ctx context.Context, key K, metadata any, opts ...UpdateOption) error {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, key, metadata, opts)
	} else {
		tmpRet = _mock.Called(ctx, key, metadata)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, K, any, ...UpdateOption) error); ok {
		r0 = returnFunc(ctx, key, metadata, opts...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMutableStoreV2_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockMutableStoreV2_Update_Call[K Comparable[K], R UniqueRecord[K, R]] struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - key K
//   - metadata any
//   - opts ...UpdateOption
func (_e *MockMutableStoreV2_Expecter[K, R]) Update(ctx interface{}, key interface{}, metadata interface{}, opts ...interface{}) *MockMutableStoreV2_Update_Call[K, R] {
	return &MockMutableStoreV2_Update_Call[K, R]{Call: _e.mock.On("Update",
		append([]interface{}{ctx, key, metadata}, opts...)...)}
}

func (_c *MockMutableStoreV2_Update_Call[K, R]) Run(run func(ctx context.Context, key K, metadata any, opts ...UpdateOption)) *MockMutableStoreV2_Update_Call[K, R] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 K
		if args[1] != nil {
			arg1 = args[1].(K)
		}
		var arg2 any
		if args[2] != nil {
			arg2 = args[2].(any)
		}
		var arg3 []UpdateOption
		var variadicArgs []UpdateOption
		if len(args) > 3 {
			variadicArgs = args[3].([]UpdateOption)
		}
		arg3 = variadicArgs
		run(
			arg0,
			arg1,
			arg2,
			arg3...,
		)
	})
	return _c
}

func (_c *MockMutableStoreV2_Update_Call[K, R]) Return(err error) *MockMutableStoreV2_Update_Call[K, R] {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMutableStoreV2_Update_Call[K, R]) RunAndReturn(run func(ctx context.Context, key K, metadata any, opts ...UpdateOption) error) *MockMutableStoreV2_Update_Call[K, R] {
	_c.Call.Return(run)
	return _c
}

// Upsert provides a mock function for the type MockMutableStoreV2
func (_mock *MockMutableStoreV2[K, R]) Upsert(ctx context.Context, key K, metadata any, opts ...UpdateOption) error {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, key, metadata, opts)
	} else {
		tmpRet = _mock.Called(ctx, key, metadata)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Upsert")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, K, any, ...UpdateOption) error); ok {
		r0 = returnFunc(ctx, key, metadata, opts...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMutableStoreV2_Upsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Upsert'
type MockMutableStoreV2_Upsert_Call[K Comparable[K], R UniqueRecord[K, R]] struct {
	*mock.Call
}

// Upsert is a helper method to define mock.On call
//   - ctx context.Context
//   - key K
//   - metadata any
//   - opts ...UpdateOption
func (_e *MockMutableStoreV2_Expecter[K, R]) Upsert(ctx interface{}, key interface{}, metadata interface{}, opts ...interface{}) *MockMutableStoreV2_Upsert_Call[K, R] {
	return &MockMutableStoreV2_Upsert_Call[K, R]{Call: _e.mock.On("Upsert",
		append([]interface{}{ctx, key, metadata}, opts...)...)}
}

func (_c *MockMutableStoreV2_Upsert_Call[K, R]) Run(run func(ctx context.Context, key K, metadata any, opts ...UpdateOption)) *MockMutableStoreV2_Upsert_Call[K, R] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 K
		if args[1] != nil {
			arg1 = args[1].(K)
		}
		var arg2 any
		if args[2] != nil {
			arg2 = args[2].(any)
		}
		var arg3 []UpdateOption
		var variadicArgs []UpdateOption
		if len(args) > 3 {
			variadicArgs = args[3].([]UpdateOption)
		}
		arg3 = variadicArgs
		run(
			arg0,
			arg1,
			arg2,
			arg3...,
		)
	})
	return _c
}

func (_c *MockMutableStoreV2_Upsert_Call[K, R]) Return(err error) *MockMutableStoreV2_Upsert_Call[K, R] {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMutableStoreV2_Upsert_Call[K, R]) RunAndReturn(run func(ctx context.Context, key K, metadata any, opts ...UpdateOption) error) *MockMutableStoreV2_Upsert_Call[K, R] {
	_c.Call.Return(run)
	return _c
}
